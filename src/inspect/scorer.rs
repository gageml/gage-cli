#![allow(dead_code)]

use std::{collections::HashMap, fmt::Display};

use pyo3::FromPyObject;

use crate::inspect::Metadata;

/// Score generated by a scorer.
#[derive(FromPyObject, Debug)]
pub struct Score {
    /// The score value.
    pub value: Value,

    /// Answer extracted from model output (optional)
    pub answer: Option<String>,

    /// Explanation of score (optional).
    pub explanation: Option<String>,

    /// Additional metadata related to the score.
    pub metadata: Option<Metadata>,
}

#[derive(FromPyObject, Clone, Debug)]
pub enum Value {
    Scalar(Scalar),
    Sequence(Vec<Scalar>),
    Map(HashMap<String, Scalar>),
}

#[derive(FromPyObject, Clone, Debug)]
pub enum Scalar {
    String(String),
    Int(i64),
    Float(f64),
    Bool(bool),
}

impl Display for Scalar {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::String(s) => s.fmt(f),
            Self::Int(i) => i.fmt(f),
            Self::Float(float) => float.fmt(f),
            Self::Bool(b) => b.fmt(f),
        }
    }
}
